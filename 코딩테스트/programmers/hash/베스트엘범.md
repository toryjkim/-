# 베스트엘범

프로그래머스의 해시맵 lv.3 문제를 풀어보았다.

## 처음 생각한 풀이 방법
내가 처음 생각했던 문제풀이
1. 각 장르별 총 점수가 필요하다.
2. 장르별 가장 많이 재생된 2곡이 필요하다.

## 풀이
```
function solution(genres, plays) {
    var answer = [];
    let pickTwoSongsByGenres = {}; // 장르별 top 2 재생 목록 ex) {"classic": [{id:3, score:100}, {id:1, score:50}], ...}
    let sumPlaysByGenres = {}; // 장르별 총 재생 수 ex) {"classic": 500, ...}
    
    ///top 2 뽑기
    for (let i = 0; i < genres.length; i++) {
        if (!pickTwoSongsByGenres[genres[i]]) { // pickTwoSongsByGenres에 장르가 없으면 새로운 Array 생성 및 곡 저장.
            pickTwoSongsByGenres[genres[i]] = new Array({id:i, score:plays[i]});
        } else if (pickTwoSongsByGenres[genres[i]].length < 2) { // pickTwoSongsByGenres에 곡이 2개 미만일 때 점수를 비교해서 순서대로 저장
            if(plays[i] > pickTwoSongsByGenres[genres[i]][0].score)
                pickTwoSongsByGenres[genres[i]].unshift({id:i, score:plays[i]});
            else
                pickTwoSongsByGenres[genres[i]].push({id:i, score:plays[i]});
        } else { // pickTwoSongsByGenres에 곡이 2개 이상일 때 점수를 비교해서 순서대로 저장후 3개가 되면 마지막 element 삭제
            if (plays[i] > pickTwoSongsByGenres[genres[i]][0].score) {
                pickTwoSongsByGenres[genres[i]].unshift({id:i, score:plays[i]});
                pickTwoSongsByGenres[genres[i]].pop();
            } else if (plays[i] > pickTwoSongsByGenres[genres[i]][1].score) {
                pickTwoSongsByGenres[genres[i]][1] = {id:i, score:plays[i]};
            }
        }
        sumPlaysByGenres[genres[i]] = (sumPlaysByGenres[genres[i]]||0) + plays[i] // 장르별 총 재생 수 저장.
    }
    
    // map 형식을 list 형식으로 바꾸기 ( 점수별로 정렬하기 위해서 ) 
    let sumPlaysByGenresList = Object.keys(sumPlaysByGenres).map(key => [key, sumPlaysByGenres[key]]);
    // 내림차순으로 정렬 ex) [["pop",4000], ["classic": 2000]]
    let sortedSumPlaysByGenresList = sumPlaysByGenresList.sort((a, b) => b[1] - a[1]);
    // 정렬된 genre를 순서로 장르별로 top2 리스트 접근 후 answer에 concat 
    for(let i = 0; i < sortedSumPlaysByGenresList.length; i++){
        let genre = sortedSumPlaysByGenresList[i][0];
        let idsSong = pickTwoSongsByGenres[genre].map(song => song.id);
        answer = answer.concat(idsSong);
    }
    return answer;
}
```
## 다른 사람 풀이.
```
function solution(genres, plays) {
    var dic = {};
    genres.forEach((t,i)=> {
        dic[t] = dic[t] ?  dic[t] + plays[i] :plays[i];        
    });

    var dupDic = {};
    return genres          
          .map((t,i)=> ({genre : t, count:plays[i] , index:i}))
          .sort((a,b)=>{               
               if(a.genre !== b.genre) return dic[b.genre] - dic[a.genre];
               if(a.count !== b.count) return b.count - a.count;
               return a.index - b.index;
           })
           .filter(t=>  {
               if(dupDic[t.genre] >= 2) return false;
               dupDic[t.genre] = dupDic[t.genre] ? dupDic[t.genre]+ 1 : 1;
               return true;
            })
           .map(t=> t.index);    
}
```
문제를 풀고난 후 댓글이 많이 달린 코드를 살펴보는 편이다. 댓글이 많이 달린만큼 상당히 흥미로워 보인다.
특히 sort 메소드에 사용된 조건식이 매우 흥미로운데, 이를 분석해 보려고한다. 그리고 sort에 대해 더 자세히 알아보고자 한다.

```
var dic = {}; // 장르별 재생 수 합
    genres.forEach((t,i)=> {
        dic[t] = dic[t] ?  dic[t] + plays[i] :plays[i];        
    });
    var songs = genres.map((t,i)=> ({genre : t, count:plays[i] , index:i}))
    console.log(songs) // [{ genre: 'classic', count: 500, index: 0 },{ genre: 'pop', count: 600, index: 1 },...]
```
songs에는 예상했던데로 각 노래코드에 해당하는 정보가 들어있다.
```
var sortedSongs = songs.sort((a,b)=>{               
               if(a.genre !== b.genre) {
                   return dic[b.genre] - dic[a.genre];
               }
               if(a.count !== b.count) {
                   return b.count - a.count;
               }
               return a.index - b.index;
           })
    console.log(sortedSongs) // [{ genre: 'pop', count: 2500, index: 4 }, { genre: 'pop', count: 600, index: 1 }, { genre: 'classic', count: 800, index: 3 },...]
```
sortedSongs에는 높은 재생수의 장르부터 낮은 재생수의 장르순으로 그리고 각 노래별 재생 순위에 따라 노래코드에 해당하는 정보들이 정렬되어있다.
위 코드를 보면 a.genre !== b.genre는 장르를 비교하고있고, a.count !== b.count는 재생 수를 비교하고 있으며, 마지막은 index를 비교한다...
이렇게 특정한 정보를 비교하는 것이 아니라, 여러개의 정보를 동시에 비교하고있는데 이게 어떻게 가능한 것인지... 아직 이해가 안된다.

```
dic = { classic: 1450, pop: 3100 }
songs = 	[
  { genre: 'classic', count: 500, index: 0 },
  { genre: 'pop', count: 600, index: 1 },
  { genre: 'classic', count: 150, index: 2 },
  { genre: 'classic', count: 800, index: 3 },
  { genre: 'pop', count: 2500, index: 4 }
]
```
그래서 songs(정렬안된 정보들)이 정렬되는 순서를 찍어봤다.

1. a = { genre: 'pop', count: 600, index: 1 }, b = { genre: 'classic', count: 500, index: 0 }   
장르가 다르기 때문에 dic[b.genre] - dic[a.genre] === 1450 - 3100 === -1650  
음수이기 때문에 순서는 바뀐다.  
songs = 	[  
  **{ genre: 'pop', count: 600, index: 1 },**  
  **{ genre: 'classic', count: 500, index: 0 },**  
  { genre: 'classic', count: 150, index: 2 },  
  { genre: 'classic', count: 800, index: 3 },  
  { genre: 'pop', count: 2500, index: 4 }  
]  

2. a = { genre: 'classic', count: 150, index: 2 },  b = { genre: 'pop', count: 600, index: 1 }  
장르가 다르기 때문에 dic[b.genre] - dic[a.genre] === 3100 - 1450 === 1650  
양수이기 때문에 순서는 바뀌지 않는다.  
songs = 	[  
  { genre: 'pop', count: 600, index: 1 },  
  { genre: 'classic', count: 500, index: 0 },  
  { genre: 'classic', count: 150, index: 2 },  
  { genre: 'classic', count: 800, index: 3 },  
  { genre: 'pop', count: 2500, index: 4 }  
]  

3. a = { genre: 'classic', count: 150, index: 2 }, b = { genre: 'classic', count: 500, index: 0 }  
장르가 같기 때문에 b.count - a.count === 500 - 150 === 350  
양수이기 때문에 순서는 바뀌지 않는다.  
songs = 	[  
  { genre: 'pop', count: 600, index: 1 },  
  { genre: 'classic', count: 500, index: 0 },  
  { genre: 'classic', count: 150, index: 2 },  
  { genre: 'classic', count: 800, index: 3 },  
  { genre: 'pop', count: 2500, index: 4 }  
]  

4. a = { genre: 'classic', count: 800, index: 3 }, { genre: 'classic', count: 500, index: 0 }   
장르가 같기 때문에 b.count - a.count === 500 - 800 === -300  
음수이기 때문에 순서는 바뀐다.   
songs = 	[  
  { genre: 'pop', count: 600, index: 1 },  
  **{ genre: 'classic', count: 800, index: 3 },**   
  { genre: 'classic', count: 150, index: 2 },  
  **{ genre: 'classic', count: 500, index: 0 },**  
  { genre: 'pop', count: 2500, index: 4 }  
]   

5. a = { genre: 'classic', count: 800, index: 3 }, b = { genre: 'pop', count: 600, index: 1 }  
장르가 다르기 때문에 dic[b.genre] - dic[a.genre] === 3100 - 1450 === 1650   
양수이기 때문에 순서는 바뀌지 않는다.  
songs = 	[  
  { genre: 'pop', count: 600, index: 1 },  
  { genre: 'classic', count: 800, index: 3 },  
  { genre: 'classic', count: 150, index: 2 },  
  { genre: 'classic', count: 500, index: 0 },  
  { genre: 'pop', count: 2500, index: 4 }  
]   

6. a = { genre: 'pop', count: 2500, index: 4 }, b = { genre: 'classic', count: 500, index: 0 }  
장르가 다르기 때문에 dic[b.genre] - dic[a.genre] === 1450 - 3100 === -1650  
음수이기 때문에 순서는 바뀐다.  
songs = 	[  
  { genre: 'pop', count: 600, index: 1 },  
  { genre: 'classic', count: 800, index: 3 },  
  { genre: 'classic', count: 150, index: 2 },  
  **{ genre: 'pop', count: 2500, index: 4 },**  
  **{ genre: 'classic', count: 500, index: 0 }**  
]   

7. a = { genre: 'pop', count: 2500, index: 4 }, b = { genre: 'classic', count: 800, index: 3 }
장르가 다르기 때문에 dic[b.genre] - dic[a.genre] === 1450 - 3100 === -1650  
음수이기 때문에 순서는 바뀐다.  
{ genre: 'pop', count: 600, index: 1 }, 
**{ genre: 'pop', count: 2500, index: 4 },**  
  { genre: 'classic', count: 150, index: 2 },  
**{ genre: 'classic', count: 800, index: 3 },**  
  { genre: 'classic', count: 500, index: 0 }  
  
8. a = { genre: 'pop', count: 2500, index: 4 }, b = { genre: 'pop', count: 600, index: 1 }  
장르가 같기 때문에 b.count - a.count === 600 - 2500 === -1900  
음수이기 때문에 순서는 바뀐다. 
**{ genre: 'pop', count: 2500, index: 4 },** 
**{ genre: 'pop', count: 600, index: 1 },**  
  { genre: 'classic', count: 150, index: 2 },  
{ genre: 'classic', count: 800, index: 3 },  
  { genre: 'classic', count: 500, index: 0 }  
### sort에 대해...

- [1, 3]인 Array가 있다면 a가 3이고 b가 1이다. 즉 a가 뒤의 인덱스를 b가 앞의 인덱스를 가리킨다.
> Array.prototype.sort((a, b) => {statement})
- statement에서 return하는 값이 0보다 크거나 같으면 a와 b는 순서가 바뀌지 않는다.
> [1,2].sort((a, b) => 1) // [1, 2]
- statement에서 return하는 값이 0보다 작으면 a와 b는 순서가 바뀐다.
>[1,2].sort((a, b) => -1) // [2, 1]



### 코드 고쳐보기.
1. 
