# 완주하지 못한 선수
## 규칙
1. 경기에 참여한 선수의 수는 1명 이상 100,000명 이하
2. 완주자(completions)는 참가자(participants)보다 한 사람 적다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있다.
4. 참가자 중에는 동명이인이 있을 수 있다.
## 첫번 째 풀이
```
function solution(participants, completions) {
    let answer = participants;
    completions.forEach(function(completion){
        let index = answer.indexOf(completion)
        if(index >= 0){
            answer.splice(index,1)
        }
    })
    return answer[0];
```
첫번 째로 생각했던 풀이 방법은 참가자 리스트인 participants를 answer 변수에 담아두고
완주자 리스트인 completions를 순회해서 각 참가자가 answer에 담겨있는지 확인 후 있다면 제거해 나가는 방식이었다.
### 결과

![image](https://user-images.githubusercontent.com/39623897/103251190-0b2ad300-49bb-11eb-81ea-e1e85c77325c.png)

보기좋게 효율성 테스트에서 전부 실패했고, 무엇이 문제였을까 생각해 보았다.

### 유추가능한 문제점
1. for문을 통한 완주자를 순회하는 코드는 n의 시간 복잡도를 가지고, indexOf는 기본적으로 선형탐색으로 해당 데이터의 인덱스를 탐색하는 메소드이기 때문에 역시 O(n)의 시간 복잡도를 가지므로, 도합 O(n2)의 시간 복잡도를 가지게 된다. 이보다는 적어도 빠른 시간복잡도의 알고리즘을 선택해야한다.

다른 탐색 알고리즘을 알아보았으나 실질적으로 가장 빠른 탐색방법인 이진탐색방법은 적용하기 힘들다는 판단을 내렸고
결국 이 문제가 속한 카테고리인 해시를 사용해 보기로 했다.

## 두번 째 풀이.
참가자가 항상 완주자 보다 한 사람 많고 동명이인이 있을 수 있음을 고려해서 2가지 경우로 탐색 시나리오를 나눠 보았다.
1. 참가자에 동명이인이 있는 경우. => 각 완주자의 이름을 key로, 해당하는 이름의 수 만큼 카운트하여 value로 hashTable 내에 저장한다. ex) {'kim':2, 'lee':1}  
참가자가 완주자보다 한 명이 더 많기 때문에 완주자로 구성된 해시테이블에서 참가자를 한명씩 차감해 나가다보면 그 수가 -1이 될 때 가 생긴다. -1이 되는 버킷에 해당하는 key가 미완주자이다.
2. 참가지에 동명이인이 없는 경우. => 미완주자는 완자주로 구성된 테이블내에 존재하지 않는다. 따라서 key값으로 검색을 해도 false가 반환된다.

이전에 공부했던 해시시테이블과 링크드리스트를 활용해서 문제를 풀어보았더니 성공이다.
```
function solution(participants, completions) {
  let hashTable = new HashTable(participants.length*2);
  let nonCompletion;
  for(let i=0; i<completions.length; i++){
    let value = hashTable.get(completions[i])
    if (value === false) {
      hashTable.put(completions[i],1);
    } else {
      hashTable.put(completions[i], value + 1);
    }
  }
  for (let i=0; i<participants.length; i++) {
    let value = hashTable.get(participants[i]);
    if (value === false) { // 참가자가 완주자리스트에 없는 경우
      console.log(value,participants[i])
      nonCompletion = participants[i]
      break;
    } else if (value !== false) { // 완주자리스트에 참가자 이름이 있는 경우 -1
      value = value -1;
      hashTable.put(participants[i], value);
    }
    if (value < 0) { // 동명이인이 있을 때 참가자 수가 완주자 수보다 많은 경우로 그 값이 -1이 되면 미완주자임을 알 수 있다.
      nonCompletion = participants[i]
      break;
    }
  }
  return nonCompletion;
}
```
![image](https://user-images.githubusercontent.com/39623897/105037773-d97cc780-5aa1-11eb-85ea-e3db5597bfc7.png

## 직접구현한 자료구조 vs map
어느정도의 성능 차이가 날지 궁금해서 같은 풀이법으로 map을 이용해서 문제를 풀어봤다.
```
function solution(participants, completions) {
  let participantsObj = new Map();
  let nonCompletion;
  for(let i=0; i<completions.length; i++){
    let numCompletion = participantsObj.get(completions[i])
    if (!numCompletion) {
      participantsObj.set(completions[i],1);
    } else {
      participantsObj.set(completions[i], numCompletion + 1);
    }
  }

  for (let i=0; i<participants.length; i++) {
    let numParticipant = participantsObj.get(participants[i]);
    if (!numParticipant) { // 참가자가 완주자리스트에 없는 경우
      console.log(numParticipant,participants[i])
      nonCompletion = participants[i]
      break;
    } else if (numParticipant !== false) { // 완주자리스트에 참가자 이름이 있는 경우 -1
      numParticipant = numParticipant -1;
      participantsObj.set(participants[i], numParticipant);
    }
    if (numParticipant < 0) { // 완주자리스트에 참가자가 
      nonCompletion = participants[i]
      break;
    }
  }
  return nonCompletion;
}
```
![image](https://user-images.githubusercontent.com/39623897/105038636-ecdc6280-5aa2-11eb-88cb-52d62b4399a3.png)

결과는 역시 내장된 map이 훨씬 빠랐다. 그리고 한가지 더 확인해 볼 수 있었던 것은 예상 했던 것 처럼 내가 만든 해시테이블은 인덱스를 만드는 알고리즘이 단순해서 한쪽의 bucket에 값들이 치우칠 경우 데이터를 불러오는 속도가 않았는데, 이와 달리 Map은 안정적인 모습을 확인할 수 있었다.

## review
코딩테스트 문제를 풀면서 단순히 문제를 풀어보는 행위가 끝이 아니라 문제를 어떻게 풀어야 하는지 곰곰이 생각해보고, 이 알고리즘이 왜 이 문제를 푸는데 알맞은 방법일지 깊이있게 생각해 봄으로서 문제를 풀어가는 능력을 향상시키는 좋은 방법이라는 생각이 들었다. 실제로 실무에서도 기능을 구현할 때 어떠한 방법으로 어떻게 구현해야할지 감이 안올 때가 있는데, 단순히 시간에 쫓겨 구글에 있는 코드를 가져다 쓰는 사람이 아닌 한번더 생각해보고 좋은 코드를 작성하는 개발자가 되자.
