# 완주하지 못한 선수
## 규칙
1. 경기에 참여한 선수의 수는 1명 이상 100,000명 이하
2. completions의 길이는 participant의 길이보다 1작다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있다.
4. 참가자 중에는 동명이인이 있을 수 있다.
## 첫번 째 풀이
```
function solution(participants, completions) {
    let answer = participants;
    completions.forEach(function(completion){
        let index = answer.indexOf(completion)
        if(index >= 0){
            answer.splice(index,1)
        }
    })
    return answer[0];
```
첫번 째로 생각했던 풀이 방법은 참가자 리스트인 participants를 answer 변수에 담아두고
완주자 리스트인 completions를 순회해서 각 참가자가 answer에 담겨있는지 확인 후 있다면 제거해 나가는 방식이었다.
### 결과

![image](https://user-images.githubusercontent.com/39623897/103251190-0b2ad300-49bb-11eb-81ea-e1e85c77325c.png)

보기좋게 효율성 테스트에서 전부 실패했고, 무엇이 문제였을까 생각해 보았다.

### 유추가능한 문제점
1. for문을 통한 완주자를 순회하는 코드는 n의 시간 복잡도를 가지고, indexOf는 기본적으로 선형탐색으로 해당 데이터의 인덱스를 탐색하는 메소드이기 때문에 역시 O(n)의 시간 복잡도를 가지므로, 도합 O(n2)의 시간 복잡도를 가지게 된다. 이보다는 적어도 빠른 시간복잡도의 알고리즘을 선택해야한다.

다른 탐색 알고리즘을 알아보았으나 실질적으로 가장 빠른 탐색방법인 이진탐색방법은 적용하기 힘들다는 판단을 내렸고
결국 이 문제의 카테고리인 해시를 사용해 보기로 했다.

## 두번 째 풀이.
participants가 항상 completions 보다 1이 많고 동명이인이 있을 수 있기 때문에, 
2가지 경우로 탐색 시나리오를 나눠 보았다.
1. participants에 동명이인이 없는 경우. => participants와 completions를 비교해서 completions에 없는 participant를 찾아낸다.
2. participants에 동명이인이 있는 경우. => 각 completion를 key로, 해당하는 이름의 수 만큼 카운트하여 저장한다. 
각 participant를 key로 completion의 숫자를 1씩 차감한다. participants가 completions보다 한 명이 많기 때문에 결국 -1이 되는 key값이
미완주자가 된다.
```
function solution(participants, completions) {
  let hashTable = new HashTable(participants.length*2);
  let nonCompletion;
  for(let i=0; i<completions.length; i++){
    let value = hashTable.get(completions[i])
    if (value === false) {
      hashTable.put(completions[i],1);
    } else {
      hashTable.put(completions[i], value + 1);
    }
  }
  for (let i=0; i<participants.length; i++) {
    let value = hashTable.get(participants[i]);
    if (value === false) { // 참가자가 완주자리스트에 없는 경우
      console.log(value,participants[i])
      nonCompletion = participants[i]
      break;
    } else if (value !== false) { // 완주자리스트에 참가자 이름이 있는 경우 -1
      value = value -1;
      hashTable.put(participants[i], value);
    }
    if (value < 0) { // 동명이인이 있을 때 참가자 수가 완주자 수보다 많은 경우
      nonCompletion = participants[i]
      break;
    }
  }
  return nonCompletion;
}
```

## review
코딩테스트 문제를 풀면서 단순히 문제를 풀어보는 행위가 끝이 아니라 문제를 어떻게 풀어야 하는지 곰곰이 생각해보고, 이 알고리즘이 왜 이 문제를 푸는데 알맞은 방법일지 깊이있게 생각해 봄으로서 문제를 풀어가는 능력을 향상시키는 좋은 방법이라는 생각이 들었다. 실제로 실무에서도 기능을 구현할 때 어떠한 방법으로 어떻게 구현해야할지 감이 안올 때가 있는데, 단순히 시간에 쫓겨 구글에 있는 코드를 가져다 쓰는 사람이 아닌 한번더 생각해보고 좋은 코드를 작성하는 개발자가 되자.
