# 완주하지 못한 선수
## 규칙
1. 경기에 참여한 선수의 수는 1명 이상 100,000명 이하
2. completions의 길이는 participant의 길이보다 1작다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있다.
4. 참가자 중에는 동명이인이 있을 수 있다.
## 첫번 째 풀이
```
function solution(participants, completions) {
    let answer = participants;
    completions.forEach(function(completion){
        let index = answer.indexOf(completion)
        if(index >= 0){
            answer.splice(index,1)
        }
    })
    return answer[0];
```
첫번 째로 생각했던 풀이 방법은 참가자 리스트인 participants를 answer 변수에 담아두고
완주자 리스트인 completions를 순회해서 각 참가자가 answer에 담겨있는지 확인 후 있다면 제거해 나가는 방식이었다.
### 결과

![image](https://user-images.githubusercontent.com/39623897/103251190-0b2ad300-49bb-11eb-81ea-e1e85c77325c.png)

보기좋게 효율성 테스트에서 전부 실패했고, 무엇이 문제였을까 생각해 보았다.

### 유추가능한 문제점
1. for문을 통한 완주자를 순회하는 코드는 n의 시간 복잡도를 가지고, indexOf는 기본적으로 선형탐색으로 통해 해당 데이터의 인덱스를 탐색하기는 메소드이기 때문에 역시 n의 시간 복잡도를 가지므로, 도합 O(n2)의 시간 복잡도를 가지게 된다. 이보다는 적어도 빠른 시간복잡도의 알고리즘을 선택해야한다. => 해쉬 자료구조로 문제를 풀어보자.

## 두번 째 풀이.
요새 알고리즘에 재미가 들려 단순 연결리스트를 동반한 해시 테이블을 구현해봤다.
```
class HashTable{
  constructor(size){
    this.data = [];
    if (size) {
      this.size = size;;
    } else {
      this.size = 100;
    }
  }

  hashing(key){
    let hash = 0;
    for(let char of key){
      hash += char.charCodeAt();
    }
    return hash
  }

  convertToIndex(hash){
    return hash % this.size
  }

  get(key){
    const hash = this.hashing(key);
    const index = this.convertToIndex(hash);
    const list = this.data[index];
    if (list === undefined){
      // if that particular table index is undefined, linked-list is not exist,
      // therefore there is no key assgined.
      return false;
    } else if (list.search(key) === false){
      // the value doesn't exist in the linked-list
      return false;
    } else{
      return list.search(key).value;
    }
  }
  put(key, value){
    const hash = this.hashing(key);
    const index = this.convertToIndex(hash);
    const list = this.data[index];
    if(list === undefined) {
      this.data[index] = new LinkedList(key, value);
    } else {
      this.data[index].append(key, value);
    }
  }
  delete(key){
    const hash = this.hashing(key);
    const index = this.convertToIndex(hash);
    const list = this.data[index];
    if (list) {
      list.delete(key);
    }
    if (list && !list.head) {
      delete this.data[index];

    }
  }
}

class LinkedList{
  constructor(key, value){
    this.head = new Node(key, value);
  }
  search(key){
    let node = this.head;
    if (node.key === key) {
      return node
    } else {
      while(node.next !== null){
        if (node.key === key) {
          return node
        } else {
          node = node.next
        }
      }
   }
    return false
  }
  append(key, value){
    const newNode = new Node(key, value);
    let node = this.head;
    if (node === null) {
      this.head = newNode;
    } else {
      while (node.next !== null) {
        node = node.next;
      }
      node.next = newNode;
    }
  }
  delete(key){
    let node = this.head;
    // if head.key is eqaul to the key received
    if (node.key === key) {
      this.head = this.head.next;
    } else {
      while (node.next !== null) {
        if (node.next.key === key) {
          node.next = node.next.next;
          break;
        } else {
          node = node.next;
        }
      }
    }
  }
}
class Node{
  constructor(key, value){
    this.value = value;
    this.key = key;
    this.next = null;
  }
}

function solution(participants, completions) {
    let hashTable = new HashTable(completions.length*2);
    let nonCompletion;
    for(let i=0; i<completions.length; i++){
        if(hashTable.get(key)){
            hashTable.get(key)
        }
        hashTable.put(completions[i], completions[i]);
    }
    for(let i=0; i<participants.length; i++){
        if(hashTable.get(participants[i])){
            hashTable.delete(participants[i]);
        }else if(!hashTable.get(participants[i])){
            nonCompletion = participants[i]
            break;
        }
    }
    return nonCompletion;
}
```
연결리스트는 key를 통해 node를 리턴해주는 search 함수와 data를 마지막 노드에 추가하는 append 함수, key를 통해 data를 삭제하는
delete 함수 3개만 구현했다. 또한 해시의 경우 hashing 함수, Index 변환 함수, key를 통해 value를 리턴하는 get 함수, 데이터를 
저장하는 put 함수, 데이터를 삭제하는 delete 함수로 기본적인 함수들만 구현했다.
4가지의 규칙을 모두 지킨 아래 4가지 케이스로 테스트를 해보았을 때 모두 테스트를 통과한다. 하지만 채점시 몇 개의 케이스를 실패하고, 아직 정확한 이유를 찾지 못 했다. 혹시 이 글을 보고 이유를 발견한 귀인이 계시다면 꼭 연락이 닿았으면 좋겠다...(ㅠㅠ)

1. participant = ["leo", "kiki", "eden"], completion = ["eden", "kiki"]
2. participant = ["marina", "josipa", "nikola", "vinko", "filipa"], completion = ["josipa", "filipa", "marina", "nikola"]
3. participant = ["mislav", "stanko", "mislav", "ana"], completion = ["stanko", "ana", "mislav"]
4. participant = ["park", "park", "lee", "lee", "kim", "marina", "josipa", "nikola", "vinko", "filipa"], completion = ["park", "lee", "lee", "kim", "josipa", "filipa", "marina", "nikola", "vinko"]

## 세 번째 풀이
두 번째 풀이에서 해시를 이용했지만 key에 해당하는 value에 key와 같은 값을 입력하여 저장했고, 이는 key값이 중복되어도 새로운 데이터가 계속 저장되어 해시 자료구조를 효율적으로 사용하지 못했던 예시였다. 어떤 값을 저장해야 해시 데이터 구조를 효율적으로 사용할 수 있을까?
key에 해당하는 데이터의 수를 value로 저장하는 방법을 생각해봤다. 예를 들어 민수, 민수 , 영종 이라는 데이터가 있다면, 
해시테이블 내에는 { 민수: 2, 영종: 1 } 로 저장 할 것이다. 



## review
약 이틀 동안 해시 테이블과 연결리스트를 다시 공부하며 예전에 공부했던 자료구조들을 다시 상기시키는 시간을 가졌다.
예전에 학교에서 공부할 때는 코딩에 이 만큼 관심이 없었어서일까 지루했던 알고리즘이 이제는 신기하게 재밌어졌다.
이번에 연결리스트와 해시 테이블을 직접 구현해서 꼭 테스트를 통과하고 싶었으나, 지식의 한계로 성공하지 못한점은 아쉽기는 하다.
하지만 언젠가는 꼭.....!!


